//
// Intended as a sample/tutorial input file for calculations using IMC physics
//   package, to detail settings that differ to other calculation types
//


type IMCPhysicsPackage;

pop            1000;
  // Total number of particles to be emitted during each time step from material. If an additional
  //   source is given, this is also the number of particles emitted from that source.

limit          10000;
  // Sets the maximum size of particle dungeons. Typically needs to be around 10*pop, and may be
  //   significantly higher for certain problems. Runtime is very dependent on this value so should
  //   not be set arbitrarily large. Would benefit from a change such that dungeon size is increased 
  //   automatically without needing to set a limit.

cycles         50;
  // The number of time steps to be used in the calculation
  // Still called cycles in many functions and subroutines to avoid breaking other
  //   calculation types

timeStepSize   0.1;
  // The time step size for the calculation in seconds


XSdata     mg;
dataType   mg; 


collisionOperator {
                    photonMG {type IMCMGstd;}
                  }

transportOperator {
                    type transportOperatorIMC;
                  }

// No tallies are required for calculation, but empty dictionaries must be given

inactiveTally {
              }

activeTally  {
    	     }

tally  {
	   }


// Geometry is as in all other calculation types.
// Here a simple infinite region is given (a perfectly reflected 1x1x1 cube)

geometry { 
    type geometryStd;
    boundary (1 1 1 1 1 1);
    graph {type shrunk;}

    surfaces {
      squareBound { id 1; type box; origin ( 0.0  0.0  0.0); halfwidth ( 0.5 0.5 0.5); }  
             }

    cells {
          }

    universes {
      root { id 1; type rootUniverse; border 1; fill mat; }
              }
}

nuclearData {

  handles { 
     mg       { type baseMgIMCDatabase; PN P0;}
  }
  
  // Dictionary containing all materials used in geometry
  // If desired to have spatial temperature variation, split geometry (above)
  //   into desired cells and set each cell fill as a DIFFERENT material
  //   (e.g. mat1, mat2, mat3, ...) then define all materials here. Even if each
  //   each mat input is identical (even including data file), a unique material object
  //   will be created allowing for a unique temperature evolution.

  materials { 

    // Example: mat
    mat {

      temp       1;
        // Initial temperature of material (will change as calculation progresses).

      composition {}
        // Empty dictionary required for composition.

      xsFile ./imcSampleMat;
        // Location of material data file containing material properties.

      volume     1;
        // Total volume that this material occupies, for now need to calculate by hand
        //   and enter here. May be room to make this automatic in the future.

    }

    // Example 2: mat2
    //mat2 { temp 1; composition {} xssFile ./imcSampleMat2; volume 1 }

} 
  
}
  
  
  
